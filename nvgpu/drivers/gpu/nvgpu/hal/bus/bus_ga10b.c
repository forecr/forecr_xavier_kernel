// SPDX-License-Identifier: GPL-2.0-only OR MIT
// SPDX-FileCopyrightText: Copyright (c) 2020-2025 NVIDIA CORPORATION & AFFILIATES. All rights reserved.

#include <nvgpu/log.h>
#include <nvgpu/io.h>
#include <nvgpu/soc.h>
#include <nvgpu/bug.h>
#include <nvgpu/gk20a.h>
#include <nvgpu/cic_mon.h>
#include <nvgpu/nvgpu_err.h>

#include "bus_ga10b.h"

#include <nvgpu/hw/ga10b/hw_bus_ga10b.h>

static u32 bus_intr0_pri_mask(void)
{
	u32 mask = bus_intr_0_pri_fecserr_m() |
		bus_intr_0_pri_timeout_m();

	return mask;
}

static u32 bus_intr_0_fb_mask(void)
{
	u32 mask = bus_intr_0_fb_req_timeout_m() |
		bus_intr_0_fb_ack_timeout_m() |
		bus_intr_0_fb_ack_extra_m() |
		bus_intr_0_fb_rdata_timeout_m() |
		bus_intr_0_fb_rdata_extra_m();

	return mask;
}

int ga10b_bus_init_hw(struct gk20a *g)
{
	u32 intr_en_mask = 0;

	/*
	 * pbus: pri related interrupts which are generated when fecs could
	 * communicate error back to host. This is the case of non-posted
	 * transactions (generally reads)
	 * pri_fecserr: This bit is set when a pri request returns from fecs
	 * with error status.
	 * pri_timeout: This bit is set when a pri request to anywhere is
	 * discarded due to timeout.
	 * priv_ring: pri error in pri hub that could not be reported to host
	 * (error on a posted transaction generally writes).
	 */

	/*
	 * Note: 1. POSTED_DEADLOCK_TIMEOUT (bit 27 of NV_PBUS_INTR_0)
	 * 			is deprecated, hence disabled.
	 *  	2. SW (bit 26 of NV_PBUS_INTR_0) Indicates a software interrupt,
	 * 			generated by writing 1 to NV_PBUS_SW_INTR_0. SW is not
	 * 			using this bit currently, hence disabled.
	 *  	3. MPMU (bit 28 of NV_PBUS_INTR_0) indicates a software
	 * 			interrupt from MPMU. SW is not using this bit currently,
	 * 			hence disabled.
	 */
	intr_en_mask =  bus_intr_en_0_pri_fecserr_m() |
			bus_intr_en_0_pri_timeout_m() |
			bus_intr_en_0_fb_req_timeout_m() |
			bus_intr_en_0_fb_ack_timeout_m() |
			bus_intr_en_0_fb_ack_extra_m() |
			bus_intr_en_0_fb_rdata_timeout_m() |
			bus_intr_en_0_fb_rdata_extra_m() |
			bus_intr_en_0_access_timeout_m();

	nvgpu_log_info(g, "bus fb_timeout=0x%x",
		bus_fb_timeout_period_v(nvgpu_readl(g,  bus_fb_timeout_r())));

	nvgpu_cic_mon_intr_stall_unit_config(g, NVGPU_CIC_INTR_UNIT_BUS, NVGPU_CIC_INTR_ENABLE);

	nvgpu_writel(g, bus_intr_en_0_r(), intr_en_mask);
	return 0;
}

void ga10b_bus_isr(struct gk20a *g)
{
	u32 bus_intr_0 = 0U;
	u32 err_type = GPU_HOST_PBUS_TIMEOUT_ERROR;
	u32 bus_intr_0_handled = 0U;

	bus_intr_0 = nvgpu_readl(g, bus_intr_0_r());

	/*
	 * These bits signal that a PRI transaction has failed or timed out
	 * pri_fecserr_m(): fecs initiated PRI transaction failed.
	 * pri_timeout_m(): PRI transaction timed out.
	 */
	if ((bus_intr_0 & bus_intr0_pri_mask()) != 0U) {
		if ((bus_intr_0 & bus_intr_0_pri_fecserr_m()) != 0U) {
			nvgpu_err (g, "host pbus fecs error");
			err_type = GPU_HOST_PBUS_FECS_ERROR;
		}
		g->ops.ptimer.isr(g);

		bus_intr_0_handled |= (bus_intr_0 & bus_intr0_pri_mask());
	}

	/*
	 * These bits indicate fatal errors in the CPU-to-Frame buffer memory.
	 */
	if ((bus_intr_0 & bus_intr_0_fb_mask()) != 0U) {
		nvgpu_err(g, "errors detected on FB access path, status: 0x%08x",
				bus_intr_0 & bus_intr_0_fb_mask());
		bus_intr_0_handled |= (bus_intr_0 & bus_intr_0_fb_mask());
	}

	/*
	 * Indicates that a request from a sideband requester has timed out.
	 */
	if ((bus_intr_0 & bus_intr_0_access_timeout_m()) != 0U) {
		nvgpu_err(g, "access timeout detected on sideband requester");
		bus_intr_0_handled |= bus_intr_0_access_timeout_m();
	}

	if (bus_intr_0 != bus_intr_0_handled) {
		nvgpu_err(g, "unhandled interrupts, status: 0x%x",
				bus_intr_0 & ~bus_intr_0_handled);
	}

	nvgpu_report_err_to_sdl(g, NVGPU_ERR_MODULE_HOST, err_type);
	nvgpu_writel(g, bus_intr_0_r(), bus_intr_0);
}
